import csv

def load_csv_data(filename):
    """
    Load CSV data and organize it into a list of dictionaries
    """
    data = []
    skipped_rows = 0
    
    with open(filename, "r") as csvfile:
        reader = csv.DictReader(csvfile)  # This automatically uses the first row as headers
        
        # Print the column headers to make sure they match
        # print(f"Column headers found: {reader.fieldnames}")
        
        for row_num, row in enumerate(reader):
            # Convert numeric fields from strings to numbers
            try:
                # Handle empty strings and convert to float
                row['prccq'] = float(row['prccq']) if row['prccq'] and row['prccq'].strip() != '' else None
                row['epsf12'] = float(row['epsf12']) if row['epsf12'] and row['epsf12'].strip() != '' else None
                # Add operating margin fields
                row['oibdpq'] = float(row['oibdpq']) if row['oibdpq'] and row['oibdpq'].strip() != '' else None
                row['dpq'] = float(row['dpq']) if row['dpq'] and row['dpq'].strip() != '' else None
                row['saleq'] = float(row['saleq']) if row['saleq'] and row['saleq'].strip() != '' else None
            except (ValueError, KeyError) as e:
                skipped_rows += 1
                if skipped_rows <= 5:  # Show first 5 errors
                    print(f"Skipping row {row_num + 2}: {e}")
                continue
                
            data.append(row)
    
    print(f"Loaded {len(data)} records from {filename}")
    if skipped_rows > 0:
        print(f"Skipped {skipped_rows} rows due to data issues")
    
    # Show a sample of the data
    print(f"\nSample of first 3 records:")
    for i, row in enumerate(data[:3]):
        print(f"Row {i+1}: ticker={row.get('tic')}, quarter={row.get('datafqtr')}, price={row.get('prccq')}, eps_ttm={row.get('epsf12')}")
    
    return data

def calculate_operating_margin(row):
    """
    Calculate operating margin using the formula: ((oibdpq−dpq)/saleq)*100
    Operating Income Before Depreciation - Depreciation & Amortization divided by Net Sales (Revenue)
    """
    if (row['oibdpq'] is None or row['dpq'] is None or row['saleq'] is None or 
        row['saleq'] == 0):
        return None
    
    operating_income = row['oibdpq'] - row['dpq']
    operating_margin = (operating_income / row['saleq']) * 100
    return operating_margin

def find_stocks_with_good_operating_margin(data, target_quarter, min_margin=10.0):
    """
    Find stocks in a specific quarter with operating margin >= min_margin (default 10%)
    """
    # Counters for debugging
    total_in_quarter = 0
    missing_data = 0
    below_margin = 0
    good_stocks = []
    
    print(f"\nAnalyzing data for {target_quarter} with operating margin >= {min_margin}%...")
    print("-" * 60)
    
    # Track some sample operating margins
    all_margins = []
    sample_data = []
    
    for row in data:
        # Check if this row is for our target quarter
        if row['datafqtr'] == target_quarter:
            total_in_quarter += 1
            
            # Calculate operating margin
            operating_margin = calculate_operating_margin(row)
            
            # Store first 10 records for inspection
            if len(sample_data) < 10:
                sample_data.append({
                    'ticker': row['tic'],
                    'oibdpq': row['oibdpq'],
                    'dpq': row['dpq'],
                    'saleq': row['saleq'],
                    'operating_margin': operating_margin
                })
            
            # Check for missing data needed for operating margin calculation
            if operating_margin is None:
                missing_data += 1
                continue
                
            all_margins.append(operating_margin)
            
            # Check if operating margin meets our criteria
            if operating_margin < min_margin:
                below_margin += 1
                continue
                
            # If we get here, it's a good stock!
            good_stocks.append({
                'ticker': row['tic'],
                'operating_margin': operating_margin,
                'price': row['prccq'],
                'eps_ttm': row['epsf12'],
                'oibdpq': row['oibdpq'],
                'dpq': row['dpq'],
                'saleq': row['saleq']
            })
    
    # Sort by operating margin (highest first)
    good_stocks.sort(key=lambda x: x['operating_margin'], reverse=True)
    
    # Print detailed breakdown
    print(f"Total stocks in {target_quarter}: {total_in_quarter}")
    print(f"Missing operating margin data: {missing_data}")
    print(f"Operating margin < {min_margin}%: {below_margin}")
    print(f"Valid stocks with operating margin >= {min_margin}%: {len(good_stocks)}")
    
    # Show sample data for debugging
    print(f"\nSample of data in {target_quarter}:")
    for i, sample in enumerate(sample_data[:5]):
        margin_str = f"{sample['operating_margin']:.2f}%" if sample['operating_margin'] is not None else "N/A"
        print(f"  {sample['ticker']}: OIBDP={sample['oibdpq']}, DP={sample['dpq']}, Sales={sample['saleq']}, Margin={margin_str}")
    
    # Show operating margin distribution
    if all_margins:
        all_margins.sort(reverse=True)
        print(f"\nOperating margin distribution:")
        print(f"  Highest margin: {max(all_margins):.2f}%")
        print(f"  Lowest margin: {min(all_margins):.2f}%")
        print(f"  Number with margin >= 20%: {len([m for m in all_margins if m >= 20])}")
        print(f"  Number with margin 15-20%: {len([m for m in all_margins if 15 <= m < 20])}")
        print(f"  Number with margin 10-15%: {len([m for m in all_margins if 10 <= m < 15])}")
        print(f"  Number with margin 5-10%: {len([m for m in all_margins if 5 <= m < 10])}")
        print(f"  Number with margin 0-5%: {len([m for m in all_margins if 0 <= m < 5])}")
        print(f"  Number with negative margin: {len([m for m in all_margins if m < 0])}")
    
    return good_stocks

def find_stocks_with_good_pe_and_margin(data, target_quarter, min_margin=10.0):
    """
    Find stocks with both good operating margin (>=10%) AND good P/E ratio (0 < P/E < 20)
    """
    # First get stocks with good operating margins
    margin_stocks = find_stocks_with_good_operating_margin(data, target_quarter, min_margin)
    
    if not margin_stocks:
        print("No stocks found meeting operating margin criteria")
        return []
    
    print(f"\nApplying P/E filter (0 < P/E < 20) to {len(margin_stocks)} stocks with good margins...")
    print("-" * 60)
    
    # Now filter by P/E ratio
    good_stocks = []
    missing_price = 0
    missing_eps = 0
    zero_eps = 0
    negative_pe = 0
    high_pe = 0
    
    for stock in margin_stocks:
        # Check for missing price data
        if stock['price'] is None:
            missing_price += 1
            continue
            
        # Check for missing EPS data
        if stock['eps_ttm'] is None:
            missing_eps += 1
            continue
            
        # Check for zero EPS (can't calculate P/E)
        if stock['eps_ttm'] == 0:
            zero_eps += 1
            continue
            
        # Calculate P/E ratio using TTM EPS
        pe_ratio = stock['price'] / stock['eps_ttm']
        
        # Check if P/E is negative (negative earnings)
        if pe_ratio <= 0:
            negative_pe += 1
            continue
            
        # Check if P/E is too high
        if pe_ratio >= 20:
            high_pe += 1
            continue
            
        # Add P/E ratio to the stock data
        stock['pe_ratio'] = pe_ratio
        good_stocks.append(stock)
    
    # Sort by operating margin (highest first)
    good_stocks.sort(key=lambda x: x['operating_margin'], reverse=True)
    
    # Print P/E filtering results
    print(f"P/E filtering results:")
    print(f"Missing price data: {missing_price}")
    print(f"Missing TTM EPS data: {missing_eps}")
    print(f"Zero TTM EPS (can't calculate P/E): {zero_eps}")
    print(f"Negative P/E (negative earnings): {negative_pe}")
    print(f"P/E >= 20 (too high): {high_pe}")
    print(f"Final stocks with margin >= {min_margin}% AND 0 < P/E < 20: {len(good_stocks)}")
    
    return good_stocks

def calculate_peg_for_stock(data, ticker, current_quarter):
    """
    Calculate PEG ratio for a specific stock using TTM EPS data
    """
    # Find current quarter data for this ticker
    current_data = None
    for row in data:
        if row['tic'] == ticker and row['datafqtr'] == current_quarter:
            current_data = row
            break
    
    if not current_data:
        return f"No data found for {ticker} in {current_quarter}"
    
    # Check for missing or zero current EPS
    if current_data['epsf12'] is None or current_data['epsf12'] == 0:
        return f"Cannot calculate P/E for {ticker} - TTM EPS is zero or missing"
    
    # Check for missing price
    if current_data['prccq'] is None:
        return f"Cannot calculate P/E for {ticker} - price is missing"
    
    current_pe = current_data['prccq'] / current_data['epsf12']
    
    # Figure out the previous year's same quarter
    # e.g., if current is 2018Q2, we want 2017Q2
    year = int(current_quarter[:4])
    quarter_part = current_quarter[4:]  # Q1, Q2, etc.
    previous_quarter = f"{year-1}{quarter_part}"
    
    # Find previous year data
    previous_data = None
    for row in data:
        if row['tic'] == ticker and row['datafqtr'] == previous_quarter:
            previous_data = row
            break
    
    if not previous_data:
        return f"No data found for {ticker} in {previous_quarter}"
    
    # Calculate EPS growth using TTM EPS
    current_eps = current_data['epsf12']
    previous_eps = previous_data['epsf12']
    
    # Better null and negative handling
    if previous_eps is None:
        return f"Cannot calculate growth for {ticker} - previous TTM EPS is None"
    
    if previous_eps <= 0:
        return f"Cannot calculate growth for {ticker} - previous TTM EPS is {previous_eps} (must be positive)"
    
    if current_eps is None:
        return f"Cannot calculate growth for {ticker} - current TTM EPS is None"
    
    # EPS growth rate as percentage
    eps_growth = ((current_eps - previous_eps) / previous_eps) * 100
    
    # Calculate PEG ratio
    if eps_growth <= 0:
        peg_ratio = "Undefined (negative or zero growth)"
    else:
        peg_ratio = current_pe / eps_growth
    
    return {
        'ticker': ticker,
        'current_quarter': current_quarter,
        'previous_quarter': previous_quarter,
        'current_eps_ttm': current_eps,
        'previous_eps_ttm': previous_eps,
        'eps_growth_percent': eps_growth,
        'pe_ratio': current_pe,
        'peg_ratio': peg_ratio
    }

def calculate_future_returns(data, ticker, base_quarter):
    """
    Calculate 1, 3, and 5-year returns for a stock from the base quarter
    """
    # Parse the base quarter
    year = int(base_quarter[:4])
    quarter_part = base_quarter[4:]  # Q1, Q2, etc.
    
    # Calculate future quarters
    future_quarters = {
        '1yr': f"{year+1}{quarter_part}",
        '3yr': f"{year+3}{quarter_part}",
        '5yr': f"{year+5}{quarter_part}"
    }
    
    # Find base price
    base_price = None
    for row in data:
        if row['tic'] == ticker and row['datafqtr'] == base_quarter:
            base_price = row['prccq']
            break
    
    if base_price is None:
        return f"No base price found for {ticker} in {base_quarter}"
    
    # Calculate returns for each period
    returns = {}
    
    for period, future_quarter in future_quarters.items():
        future_price = None
        for row in data:
            if row['tic'] == ticker and row['datafqtr'] == future_quarter:
                future_price = row['prccq']
                break
        
        if future_price is None:
            returns[period] = f"No data for {future_quarter}"
        else:
            # Calculate total return percentage
            total_return = ((future_price - base_price) / base_price) * 100
            returns[period] = {
                'future_quarter': future_quarter,
                'base_price': base_price,
                'future_price': future_price,
                'total_return_pct': total_return
            }
    
    return returns

def analyze_quarter(data, quarter, min_margin=10.0):
    """
    Complete analysis: find stocks with good operating margins, good P/E ratios, calculate PEG ratios, then returns
    """
    print(f"\n" + "="*50)
    print(f"ANALYZING QUARTER: {quarter}")
    print(f"="*50)
    
    # Step 1: Find stocks with good operating margins AND good P/E ratios
    good_stocks = find_stocks_with_good_pe_and_margin(data, quarter, min_margin)
    
    if not good_stocks:
        print("No stocks found meeting both operating margin and P/E criteria")
        return [], []
    
    # Show ALL stocks that pass both filters
    print(f"\nAll stocks with operating margin >= {min_margin}% AND P/E < 20:")
    print(f"{'Ticker':<8} {'Op Margin %':<12} {'P/E Ratio':<10} {'Price':<10} {'TTM_EPS':<10}")
    print("-" * 54)
    
    for stock in good_stocks:
        print(f"{stock['ticker']:<8} {stock['operating_margin']:<12.2f} {stock['pe_ratio']:<10.2f} {stock['price']:<10.2f} {stock['eps_ttm']:<10.2f}")
    
    # Step 2: Calculate PEG ratios for stocks that pass filters
    print(f"\nCalculating PEG ratios for filtered stocks...")
    print("-" * 60)
    good_peg_tickers = []

    for stock in good_stocks:
        ticker = stock['ticker']
        
        peg_result = calculate_peg_for_stock(data, ticker, quarter)
        
        if isinstance(peg_result, str):  # Error message
            print(f"  Error for {ticker}: {peg_result}")
        else:
            GOOD_PEG = 1
            if not isinstance(peg_result['peg_ratio'], str) and peg_result['peg_ratio'] < GOOD_PEG:
                good_peg_tickers.append(ticker)
    
    print(f"\nStocks with good PEG ratios (PEG < 1): {', '.join(good_peg_tickers) if good_peg_tickers else 'None'}")
    
    # Step 3: Calculate future returns - MOVED TO THE END
    final_tickers = good_peg_tickers if good_peg_tickers else [stock['ticker'] for stock in good_stocks]
    
    if final_tickers:
        print(f"\n" + "="*80)
        print(f"FUTURE RETURNS ANALYSIS")
        print(f"Analyzing returns for {len(final_tickers)} stocks")
        print(f"="*80)
        
        # Create a summary table
        returns_summary = []
        
        for ticker in final_tickers:
            print(f"\nCalculating returns for {ticker}...")
            returns = calculate_future_returns(data, ticker, quarter)
            
            if isinstance(returns, str):  # Error message
                print(f"  Error: {returns}")
                continue
            
            # Add to summary
            summary_row = {'ticker': ticker}
            
            print(f"  Base Quarter: {quarter}")
            for period in ['1yr', '3yr', '5yr']:
                if isinstance(returns[period], dict):
                    ret_data = returns[period]
                    print(f"  {period.upper()} ({ret_data['future_quarter']}): "
                          f"${ret_data['base_price']:.2f} → ${ret_data['future_price']:.2f} "
                          f"({ret_data['total_return_pct']:+.1f}%)")
                    summary_row[f'{period}_return'] = ret_data['total_return_pct']
                    summary_row[f'{period}_quarter'] = ret_data['future_quarter']
                else:
                    print(f"  {period.upper()}: {returns[period]}")
                    summary_row[f'{period}_return'] = None
                    summary_row[f'{period}_quarter'] = None
            
            returns_summary.append(summary_row)
        
        # Print final summary table
        if returns_summary:
            print(f"\n" + "="*80)
            print(f"FINAL RETURNS SUMMARY TABLE")
            print(f"="*80)
            print(f"{'Ticker':<8} {'1-Year %':<12} {'3-Year %':<12} {'5-Year %':<12}")
            print("-" * 48)
            
            # Calculate averages
            valid_1yr = []
            valid_3yr = []
            valid_5yr = []
            
            for row in returns_summary:
                ticker = row['ticker']
                
                # Format return percentages
                ret_1yr = f"{row['1yr_return']:+.1f}%" if row['1yr_return'] is not None else "N/A"
                ret_3yr = f"{row['3yr_return']:+.1f}%" if row['3yr_return'] is not None else "N/A"
                ret_5yr = f"{row['5yr_return']:+.1f}%" if row['5yr_return'] is not None else "N/A"
                
                print(f"{ticker:<8} {ret_1yr:<12} {ret_3yr:<12} {ret_5yr:<12}")
                
                # Collect valid returns for averaging
                if row['1yr_return'] is not None:
                    valid_1yr.append(row['1yr_return'])
                if row['3yr_return'] is not None:
                    valid_3yr.append(row['3yr_return'])
                if row['5yr_return'] is not None:
                    valid_5yr.append(row['5yr_return'])
            
            # Print averages
            print("-" * 48)
            avg_1yr = sum(valid_1yr) / len(valid_1yr) if valid_1yr else None
            avg_3yr = sum(valid_3yr) / len(valid_3yr) if valid_3yr else None
            avg_5yr = sum(valid_5yr) / len(valid_5yr) if valid_5yr else None
            
            avg_1yr_str = f"{avg_1yr:+.1f}%" if avg_1yr is not None else "N/A"
            avg_3yr_str = f"{avg_3yr:+.1f}%" if avg_3yr is not None else "N/A"
            avg_5yr_str = f"{avg_5yr:+.1f}%" if avg_5yr is not None else "N/A"
            
            print(f"{'AVERAGE':<8} {avg_1yr_str:<12} {avg_3yr_str:<12} {avg_5yr_str:<12}")
            
            # Print sample sizes
            print(f"{'SAMPLES':<8} {len(valid_1yr):<12} {len(valid_3yr):<12} {len(valid_5yr):<12}")
    
    return good_stocks, final_tickers


# Main execution
if __name__ == "__main__":
    # Load your data (update filename as needed)
    print("Loading healthcare.csv...")
    
    try:
        data = load_csv_data("healthcare.csv")
        
        # Analyze a specific quarter with operating margin filter
        target_quarter = "2016Q3"  # Change this to whatever quarter you want
        min_operating_margin = 10.0  # Minimum operating margin percentage
        
        filtered_stocks, final_tickers = analyze_quarter(data, target_quarter, min_operating_margin)
        
        # You can also run individual functions:
        # margin_stocks = find_stocks_with_good_operating_margin(data, "2016Q1", 10.0)
        # combined_stocks = find_stocks_with_good_pe_and_margin(data, "2016Q1", 10.0)
        # peg_data = calculate_peg_for_stock(data, "JNJ", "2016Q1")
        # returns_data = calculate_future_returns(data, "JNJ", "2016Q1")
        
    except Exception as e:
        print(f"An error occurred: {e}")
